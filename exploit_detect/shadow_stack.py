# -------------------------------------------------------------------------------
#
#   Copyright (C) 2018 Cisco Talos Security Intelligence and Research Group
#
#   PyREBox: Python scriptable Reverse Engineering Sandbox
#   Author: Xabier Ugarte-Pedrero
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License version 2 as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#   MA 02110-1301, USA.
#
# -------------------------------------------------------------------------------

from __future__ import print_function

requirements = ["plugins.guest_agent"]

# Determine TARGET_LONG_SIZE
from api import get_os_bits
TARGET_LONG_SIZE = get_os_bits() / 8

# Callback manager
cm = None
pyrebox_print = None
target_procname = None
target_pgd = None

def opcode_range(callback_name, params):
    global cm
    from ipython_shell import start_shell
    import api

    cpu_index = params["cpu_index"]
    cpu = params["cpu"]
    cur_pc = params["cur_pc"]
    next_pc = params["next_pc"]
    insn_size = params["insn_size"]
    pgd = api.get_running_process(cpu_index)

    opcode = cm.get_trigger_var(callback_name, "opcode")

    if TARGET_LONG_SIZE == 4:
        pyrebox_print("Stack not matching at %08x: %08x PGD: %x" % (cur_pc, next_pc, pgd))
    else:
        pyrebox_print("Stack not matching at %016x: %016x PGD: %x" % (cur_pc, next_pc, pgd))

    start_shell()

def do_print_shadow(line):
    import api
    global cm
    cm.call_trigger_function("call_e8", "print_shadow_stack")
    cm.call_trigger_function("call_ff", "print_shadow_stack")
    cm.call_trigger_function("call_9a", "print_shadow_stack")
    cm.call_trigger_function("ret_c3", "print_shadow_stack")
    cm.call_trigger_function("ret_cb", "print_shadow_stack")
    cm.call_trigger_function("ret_c2", "print_shadow_stack")
    cm.call_trigger_function("ret_ca", "print_shadow_stack")


def module_entry_point(params):
    '''
        Callback on the entry point of the main module being monitored
    '''
    global cm
    global entry_point_bp
    from api import CallbackManager
    import api
    import functools
    from ipython_shell import start_shell

    # Get pameters
    cpu_index = params["cpu_index"]
    cpu = params["cpu"]

    # Disable the entrypoint
    entry_point_bp.disable()

    # Get running process
    pgd = api.get_running_process(cpu_index)

    #E8 cw   CALL rel16  Call near, relative, displacement relative to next instruction
    #E8 cd   CALL rel32  Call near, relative, displacement relative to next instruction
    #FF /2   CALL r/m16  Call near, absolute indirect, address given in r/m16
    #FF /2   CALL r/m32  Call near, absolute indirect, address given in r/m32
    #9A cd   CALL ptr16:16   Call far, absolute, address given in operand
    #9A cp   CALL ptr16:32   Call far, absolute, address given in operand
    #FF /3   CALL m16:16 Call far, absolute indirect, address given in m16:16
    #FF /3   CALL m16:32 Call far, absolute indirect, address given in m16:32

    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range,"call_e8"), name="call_e8", start_opcode=0xE8, end_opcode=0xE8)
    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range,"call_ff"), name="call_ff", start_opcode=0xFF, end_opcode=0xFF)
    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range,"call_9a"), name="call_9a", start_opcode=0x9A, end_opcode=0x9A)

    #C3 RET NP Valid Valid Near return to calling procedure.
    #CB RET NP Valid Valid Far return to calling procedure.
    #C2 iw RET imm16 I Valid Valid Near return to calling procedure and pop imm16 bytes from stack.
    #CA iw RET imm16 I Valid Valid Far return to calling procedure and pop imm16 bytes from stack.

    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range, "ret_c3"), name="ret_c3", start_opcode=0xC3, end_opcode=0xC3)
    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range, "ret_cb"), name="ret_cb", start_opcode=0xCB, end_opcode=0xCB)
    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range, "ret_c2"), name="ret_c2", start_opcode=0xC2, end_opcode=0xC2)
    cm.add_callback(CallbackManager.OPCODE_RANGE_CB, functools.partial(opcode_range, "ret_ca"), name="ret_ca", start_opcode=0xCA, end_opcode=0xCA)

    cm.add_trigger("call_e8", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("call_e8", "pgd", pgd)
    cm.set_trigger_var("call_e8", "thread_independent", 0)

    cm.add_trigger("call_ff", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("call_ff", "pgd", pgd)
    cm.set_trigger_var("call_ff", "thread_independent", 0)


    cm.add_trigger("call_9a", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("call_9a", "pgd", pgd)
    cm.set_trigger_var("call_9a", "thread_independent", 0)


    cm.add_trigger("ret_c3", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("ret_c3", "pgd", pgd)
    cm.set_trigger_var("ret_c3", "thread_independent", 0)


    cm.add_trigger("ret_cb", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("ret_cb", "pgd", pgd)
    cm.set_trigger_var("ret_cb", "thread_independent", 0)


    cm.add_trigger("ret_c2", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("ret_c2", "pgd", pgd)
    cm.set_trigger_var("ret_c2", "thread_independent", 0)


    cm.add_trigger("ret_ca", "exploit_detect/trigger_shadow_stack.so")
    cm.set_trigger_var("ret_ca", "pgd", pgd)
    cm.set_trigger_var("ret_ca", "thread_independent", 0)

    pyrebox_print("Started monitoring process")

    # Start monitoring process
    api.start_monitoring_process(pgd)

def load_module(params):
    '''
        Callback trigger for every module loaded.
    '''
    global cm
    global pyrebox_print
    global entry_point_bp
    global target_pgd
    global target_procname
    import pefile
    import api
    from api import BP

    pid = params["pid"]
    pgd = params["pgd"]
    base = params["base"]
    size = params["size"]
    name = params["name"]
    fullname = params["fullname"]

    if pgd == target_pgd and target_procname.lower().startswith(name.lower()):
        # Loaded main module, try to read EP
        ep = None
        try:
            pe_data = api.r_va(pgd, base, 0x1000)
            pe = pefile.PE(data=pe_data)
            ep = base + pe.OPTIONAL_HEADER.AddressOfEntryPoint
        except Exception as e:
            print(e)
            pyrebox_print("Could not read EP from module %s on load" % name)

        # If we have the EP, put a breakpoint there
        if ep is not None:
            pyrebox_print("The entry point for %s is 0x%x\n" % (target_procname, ep))

            cm.rm_callback("load_module")

            pyrebox_print("Setting BP on entrypoint")

            # Set a breakpoint on the EP, that will start a shell
            entry_point_bp = BP(ep, pgd, new_style = True, func = module_entry_point)
            entry_point_bp.enable()

def new_proc(params):
    '''
        Callback for new process creation.
    '''
    global cm
    global target_procname
    global target_pgd
    global pyrebox_print
    from api import CallbackManager
    import api

    # Get parameters
    pid = params["pid"]
    pgd = params["pgd"]
    name = params["name"]

    # Log process creation
    pyrebox_print("Created process %s - PID: %016x - PGD: %016x" % (name, pid, pgd))

    # Add module load callback
    if target_procname is not None and target_procname in name.lower():
        # Set target PGD
        target_pgd = pgd
        pyrebox_print("Adding module load callback on PGD %x" % pgd)
        cm.add_callback(CallbackManager.LOADMODULE_CB, load_module, pgd = pgd, name="load_module")


def do_set_target(line):
    '''Set target process - Custom command

       Set a target process name. When a process with this name is created,
       the script will start monitoring context changes and retrieve
       the module entry point as soon as it is available in memory. Then
       it will place a breakpoint on the entry point.
    '''
    global pyrebox_print
    global target_procname
    target_procname = line.strip()
    pyrebox_print("Waiting for process %s to start\n" % target_procname)

def do_stop_monitoring(line):
    '''
        Stop monitoring process
    '''
    global target_pgd
    import api
    api.stop_monitoring_process(target_pgd)
    cm.rm_callback("call_e8")
    cm.rm_callback("call_ff")
    cm.rm_callback("call_9a")
    cm.rm_callback("ret_c3")
    cm.rm_callback("ret_cb")
    cm.rm_callback("ret_c2")
    cm.rm_callback("ret_ca")

def clean():
    '''
    Clean up everything. At least you need to place this
    clean() call to the callback manager, that will
    unregister all the registered callbacks.
    '''
    global cm
    global pyrebox_print
    pyrebox_print("[*]    Cleaning module")
    cm.clean()
    pyrebox_print("[*]    Cleaned module")

def initialize_callbacks(module_hdl, printer):
    '''
    Initilize callbacks for this module. This function
    will be triggered whenever import_module command
    is triggered.
    '''
    global cm
    global pyrebox_print
    global target_procname
    from api import CallbackManager
    from plugins.guest_agent import guest_agent
    pyrebox_print = printer
    pyrebox_print("[*]    Initializing callbacks")
    cm = CallbackManager(module_hdl, new_style = True)
    cm.add_callback(CallbackManager.CREATEPROC_CB, new_proc, name="vmi_new_proc")
    pyrebox_print("[*]    Initialized callbacks")

    # For execution automation, see other examples, such as generic_unpacker 

if __name__ == "__main__":
    print("[*] Loading python module %s" % (__file__))
