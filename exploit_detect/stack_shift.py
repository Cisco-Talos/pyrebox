# -------------------------------------------------------------------------------
#
#   Copyright (C) 2018 Cisco Talos Security Intelligence and Research Group
#
#   PyREBox: Python scriptable Reverse Engineering Sandbox
#   Author: Xabier Ugarte-Pedrero
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License version 2 as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#   MA 02110-1301, USA.
#
# -------------------------------------------------------------------------------


from api import CallbackManager
from .mem_info import VADRegion
from .mem_info import get_vads
from .mem_info import get_stacks

# Callback manager
cm = None
pyrebox_print = None
target_procname = None
target_pgd = None
vads = []
stacks = []

def block_exec(params):
    global cm
    global page_status
    global vads
    global stacks
    import api
    from ipython_shell import start_shell

    cpu_index = params["cpu_index"]
    cpu = params["cpu"]
    tb = params["tb"]
    cur_pc = params["cur_pc"]
    next_pc = params["next_pc"]

    in_stack = False
    for s in stacks:
        if cpu.ESP >= s[1] and cpu.ESP <= s[0]:
            in_stack = True
            break
    # Second chance, re-compute list of stacks
    if not in_stack:
        stacks = get_stacks(cpu.CR3)
    for s in stacks:
        if cpu.ESP >= s[1] and cpu.ESP <= s[0]:
            in_stack = True
            break
    if not in_stack:
        vads = get_vads(cpu.CR3)
        pyrebox_print("=============================================================================")
        for v in vads:
            if cpu.ESP >= v.start and cpu.ESP < v.end:
                pyrebox_print(str(v))
        pyrebox_print("=============================================================================")
        for s1,s2 in stacks:
            pyrebox_print("Stack Base: %x - Stack Limit: %x" % (s1,s2))
        pyrebox_print("=============================================================================")
        pyrebox_print("Stack pivot detected: (TIB: %x) - %x" % (cpu.FS['base'], cpu.ESP))
        start_shell()

def new_proc(params):
    global cm
    global target_procname
    global target_pgd
    global pyrebox_print
    import api

    pid = params["pid"]
    pgd = params["pgd"]
    name = params["name"]


    if target_procname is not None and target_procname in name.lower():
        pyrebox_print("Started monitoring process %s" % name)

        cm.add_trigger("block_end", "exploit_detect/trigger_block_end_stack_shift.so")
        cm.set_trigger_var("block_end", "shift", 0x1000)
        cm.set_trigger_var("block_end", "pgd", pgd)
        cm.set_trigger_var("block_end", "skip_context_change", 1)

        api.start_monitoring_process(pgd)
        target_pgd = pgd


def do_set_target_stack(line):
    '''Set target process - Custom command

       Set a target process name. When a process with this name is created,
       the script will start monitoring context changes and retrieve
       the module entry point as soon as it is available in memory. Then
       it will place a breakpoint on the entry point.
    '''
    global pyrebox_print
    global target_procname
    import api
    target_procname = line.strip().lower()
    for p in api.get_process_list():
        if target_procname in p["name"].lower():
            new_proc(p)
            return
    
    pyrebox_print("Waiting for process %s to start\n" % target_procname)


def do_stop_monitoring_stack(line):
    '''
        Stop monitoring process
    '''
    global target_pgd
    import api
    api.stop_monitoring_process(target_pgd)
    cm.rm_callback("block_end")


def clean():
    '''
    Clean up everything. At least you need to place this
    clean() call to the callback manager, that will
    unregister all the registered callbacks.
    '''
    global cm
    global pyrebox_print
    pyrebox_print("[*]    Cleaning module")
    cm.clean()
    pyrebox_print("[*]    Cleaned module")


def initialize_callbacks(module_hdl, printer):
    '''
    Initilize callbacks for this module. This function
    will be triggered whenever import_module command
    is triggered.
    '''
    global cm
    global pyrebox_print
    pyrebox_print = printer
    pyrebox_print("[*]    Initializing callbacks")
    cm = CallbackManager(module_hdl, new_style = True)
    cm.add_callback(CallbackManager.CREATEPROC_CB, new_proc, name="vmi_new_proc")
    cm.add_callback(CallbackManager.BLOCK_END_CB, block_exec, name="block_end")
    pyrebox_print("[*]    Initialized callbacks")


if __name__ == "__main__":
    print("[*] Loading python module %s" % (__file__))
